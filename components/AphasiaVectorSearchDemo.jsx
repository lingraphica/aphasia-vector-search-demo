import React, { useState, useEffect } from 'react';

// Mock embedding vectors (simplistic for demonstration purposes)
// In a real implementation, these would be generated by an on-device LLM
const mockEmbeddings = {
    "apple": [0.8, 0.1, 0.3, 0.2, 0.1],
    "banana": [0.7, 0.2, 0.5, 0.1, 0.0],
    "water": [0.1, 0.8, 0.2, 0.3, 0.1],
    "coffee": [0.2, 0.7, 0.1, 0.4, 0.3],
    "chair": [0.3, 0.2, 0.8, 0.1, 0.2],
    "table": [0.4, 0.1, 0.7, 0.2, 0.3],
    "dog": [0.5, 0.3, 0.1, 0.8, 0.2],
    "cat": [0.6, 0.2, 0.1, 0.7, 0.3],
    "toothbrush": [0.1, 0.5, 0.3, 0.2, 0.8],
    "comb": [0.2, 0.4, 0.2, 0.3, 0.7]
};

// Mock query embeddings for different search terms
const mockQueryEmbeddings = {
    // Food-related queries
    "red fruit": [0.8, 0.2, 0.3, 0.1, 0.1],
    "something to eat": [0.7, 0.1, 0.4, 0.1, 0.1],
    "yellow food": [0.7, 0.3, 0.5, 0.0, 0.0],

    // Drink-related queries
    "something to drink": [0.2, 0.8, 0.1, 0.3, 0.2],
    "hot beverage": [0.1, 0.7, 0.2, 0.4, 0.3],

    // Furniture-related queries
    "something to sit on": [0.3, 0.1, 0.8, 0.2, 0.1],
    "furniture": [0.4, 0.2, 0.7, 0.1, 0.2],

    // Animal-related queries
    "pet animal": [0.5, 0.2, 0.1, 0.8, 0.1],
    "animal that barks": [0.5, 0.3, 0.0, 0.8, 0.1],

    // Personal care-related queries
    "bathroom item": [0.2, 0.5, 0.2, 0.3, 0.7],
    "teeth cleaning": [0.1, 0.4, 0.2, 0.2, 0.8]
};

// Sample card data
const cardData = [
    {
        id: 1,
        word: "Apple",
        description: "A round fruit with red, green, or yellow skin and crisp, juicy flesh",
        category: "Food > Fruit",
        image: "/images/apple.png"
    },
    {
        id: 2,
        word: "Banana",
        description: "A long curved fruit with yellow skin and soft sweet flesh",
        category: "Food > Fruit",
        image: "/images/banana.png"
    },
    {
        id: 3,
        word: "Water",
        description: "Clear liquid essential for life, used for drinking and washing",
        category: "Drink > Basic",
        image: "/images/water.png"
    },
    {
        id: 4,
        word: "Coffee",
        description: "Hot beverage made from roasted coffee beans",
        category: "Drink > Hot Beverage",
        image: "/images/coffee.png"
    },
    {
        id: 5,
        word: "Chair",
        description: "Furniture designed for sitting with a seat, legs, and back",
        category: "Furniture > Seating",
        image: "/images/chair.png"
    },
    {
        id: 6,
        word: "Table",
        description: "Furniture with a flat top and one or more legs",
        category: "Furniture > Surface",
        image: "/images/table.png"
    },
    {
        id: 7,
        word: "Dog",
        description: "Four-legged domesticated animal that barks",
        category: "Animal > Pet",
        image: "/images/dog.jpg"
    },
    {
        id: 8,
        word: "Cat",
        description: "Small furry domesticated animal that meows",
        category: "Animal > Pet",
        image: "/images/cat.jpeg"
    },
    {
        id: 9,
        word: "Toothbrush",
        description: "Tool with bristles used for cleaning teeth",
        category: "Personal Care > Dental",
        image: "/images/toothbrush.jpg"
    },
    {
        id: 10,
        word: "Comb",
        description: "Toothed device used for arranging or styling hair",
        category: "Personal Care > Hair",
        image: "/images/comb.jpg"
    }
];

// Function to calculate cosine similarity between vectors
const cosineSimilarity = (vectorA, vectorB) => {
    if (vectorA.length !== vectorB.length) {
        throw new Error("Vectors must have the same length");
    }

    let dotProduct = 0;
    let magnitudeA = 0;
    let magnitudeB = 0;

    for (let i = 0; i < vectorA.length; i++) {
        dotProduct += vectorA[i] * vectorB[i];
        magnitudeA += vectorA[i] * vectorA[i];
        magnitudeB += vectorB[i] * vectorB[i];
    }

    magnitudeA = Math.sqrt(magnitudeA);
    magnitudeB = Math.sqrt(magnitudeB);

    if (magnitudeA === 0 || magnitudeB === 0) {
        return 0;
    }

    return dotProduct / (magnitudeA * magnitudeB);
};

// Mock function to simulate generating query embedding with an LLM
const generateQueryEmbedding = (query) => {
    // Check if we have a predefined embedding for this query
    const normalizedQuery = query.toLowerCase().trim();

    // Check for exact match
    if (mockQueryEmbeddings[normalizedQuery]) {
        return mockQueryEmbeddings[normalizedQuery];
    }

    // Check for partial matches - simplistic, but demonstrates the concept
    for (const [key, vector] of Object.entries(mockQueryEmbeddings)) {
        if (normalizedQuery.includes(key) || key.includes(normalizedQuery)) {
            return vector;
        }
    }

    // Handle typos - very simplified approach
    // In a real implementation, this would be handled by the LLM's understanding
    const words = normalizedQuery.split(/\s+/);
    for (const word of words) {
        for (const [key, vector] of Object.entries(mockQueryEmbeddings)) {
            // Simple edit distance approximation
            if (levenshteinDistance(word, key) <= 2 || key.split(/\s+/).some(k => levenshteinDistance(word, k) <= 2)) {
                return vector;
            }
        }
    }

    // Fallback - return a random embedding
    return Object.values(mockQueryEmbeddings)[Math.floor(Math.random() * Object.values(mockQueryEmbeddings).length)];
};

// Simple Levenshtein distance implementation to simulate fuzzy matching for typos
const levenshteinDistance = (a, b) => {
    const matrix = [];

    // Initialize matrix
    for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }
    for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }

    // Fill matrix
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1, // substitution
                    matrix[i][j - 1] + 1,     // insertion
                    matrix[i - 1][j] + 1      // deletion
                );
            }
        }
    }

    return matrix[b.length][a.length];
};

// Main component
// Force proper text contrast regardless of system dark mode
const textStyles = {
    heading: "text-gray-900 dark:text-gray-900",
    subheading: "text-gray-800 dark:text-gray-800",
    paragraph: "text-gray-700 dark:text-gray-700",
    lightText: "text-gray-600 dark:text-gray-600"
};

const AphasiaVectorSearchDemo = () => {
    const [searchQuery, setSearchQuery] = useState("");
    const [searchResults, setSearchResults] = useState([]);
    const [recentlySpoken, setRecentlySpoken] = useState([]);
    const [isSearching, setIsSearching] = useState(false);
    const [demoQueries, setDemoQueries] = useState([
        "red fruit",
        "something to drink",
        "something to sit on",
        "pet animal",
        "bathroom item"
    ]);
    const [demoTypos, setDemoTypos] = useState([
        "appel",
        "sumthing to drink",
        "furniture for sitting",
        "animel that barks"
    ]);

    // Perform vector search
    const performVectorSearch = (query) => {
        setIsSearching(true);

        // Simulate network delay for demo purposes
        setTimeout(() => {
            try {
                // Generate query embedding
                const queryEmbedding = generateQueryEmbedding(query);

                // Calculate similarity scores for all cards
                const results = Object.entries(mockEmbeddings).map(([word, embedding]) => {
                    const card = cardData.find(c => c.word.toLowerCase() === word);
                    const similarityScore = cosineSimilarity(queryEmbedding, embedding);

                    return {
                        ...card,
                        similarityScore
                    };
                });

                // Sort by similarity score
                const sortedResults = results.sort((a, b) => b.similarityScore - a.similarityScore);

                // Set results
                setSearchResults(sortedResults);
            } catch (error) {
                console.error("Error performing search:", error);
                setSearchResults([]);
            } finally {
                setIsSearching(false);
            }
        }, 500);
    };

    // Handle search input change
    const handleSearchChange = (e) => {
        const query = e.target.value;
        setSearchQuery(query);

        // Perform search as user types (with debounce in a real app)
        if (query.length > 2) {
            performVectorSearch(query);
        } else if (query.length === 0) {
            setSearchResults(cardData);
        }
    };

    // Handle card click - speak the word
    const speakWord = (word) => {
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(word);
            utterance.rate = 0.9; // Slightly slower for clarity
            window.speechSynthesis.speak(utterance);

            // Add to recently spoken
            setRecentlySpoken(prev => {
                const newList = [word, ...prev.filter(w => w !== word)].slice(0, 5);
                return newList;
            });
        } else {
            console.log(`Speaking: ${word}`);
        }
    };

    // Apply a demo query
    const applyDemoQuery = (query) => {
        setSearchQuery(query);
        performVectorSearch(query);
    };

    // Initialize with all cards visible
    useEffect(() => {
        setSearchResults(cardData);
    }, []);

    return (
        <div className="p-6 max-w-4xl mx-auto bg-gray-50 rounded-lg">
            <h1 className={`text-2xl font-bold mb-2 ${textStyles.heading}`}>Aphasia Communication Cards</h1>
            <p className={`mb-6 ${textStyles.lightText}`}>Using vector search technology to find words when you can't remember them</p>

            {/* Search bar */}
            <div className="mb-6">
                <div className="flex gap-2">
                    <input
                        type="text"
                        value={searchQuery}
                        onChange={handleSearchChange}
                        placeholder="Describe what you're looking for..."
                        className="w-full p-3 border rounded shadow-sm"
                    />
                    {isSearching && (
                        <div className="flex items-center">
                            <div className="animate-pulse text-blue-500">Searching...</div>
                        </div>
                    )}
                </div>

                {/* Demo queries */}
                <div className="mt-4">
                    <h3 className={`text-sm font-medium mb-2 ${textStyles.paragraph}`}>Try these example searches:</h3>
                    <div className="flex flex-wrap gap-2">
                        {demoQueries.map((query, index) => (
                            <button
                                key={`query-${index}`}
                                onClick={() => applyDemoQuery(query)}
                                className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm hover:bg-blue-200"
                            >
                                {query}
                            </button>
                        ))}
                    </div>
                </div>

                {/* Demo typo queries */}
                <div className="mt-3">
                    <h3 className={`text-sm font-medium mb-2 ${textStyles.paragraph}`}>Or with typos (still works!):</h3>
                    <div className="flex flex-wrap gap-2">
                        {demoTypos.map((query, index) => (
                            <button
                                key={`typo-${index}`}
                                onClick={() => applyDemoQuery(query)}
                                className="px-3 py-1 bg-purple-100 text-purple-800 rounded-full text-sm hover:bg-purple-200"
                            >
                                {query}
                            </button>
                        ))}
                    </div>
                </div>
            </div>

            {/* Recently spoken */}
            {recentlySpoken.length > 0 && (
                <div className="mb-6 p-4 bg-white rounded-lg shadow-sm">
                    <h2 className={`text-lg font-semibold mb-2 ${textStyles.subheading}`}>Recently Used</h2>
                    <div className="flex flex-wrap gap-2">
                        {recentlySpoken.map((word, index) => (
                            <button
                                key={`recent-${index}`}
                                onClick={() => speakWord(word)}
                                className="px-4 py-2 bg-green-100 text-green-800 rounded-lg hover:bg-green-200"
                            >
                                {word}
                            </button>
                        ))}
                    </div>
                </div>
            )}

            {/* Results */}
            <div className="mt-4">
                <h2 className={`text-lg font-semibold mb-3 ${textStyles.subheading}`}>
                    {searchQuery ? `Results for "${searchQuery}"` : "All Cards"}
                </h2>

                {searchResults.length > 0 ? (
                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        {searchResults.map((card) => (
                            <div
                                key={card.id}
                                onClick={() => speakWord(card.word)}
                                className="border bg-white rounded-lg p-4 flex flex-col items-center cursor-pointer hover:bg-blue-50 transition shadow-sm"
                            >
                                <img
                                    src={card.image}
                                    alt={card.word}
                                    className="w-16 h-16 object-contain mb-2 rounded"
                                />
                                <p className={`font-bold text-lg ${textStyles.heading}`}>{card.word}</p>
                                <p className={`text-xs mb-1 ${textStyles.lightText}`}>{card.category}</p>

                                {/* Show matching score for search results */}
                                {searchQuery && card.similarityScore !== undefined && (
                                    <div className="mt-1 w-full">
                                        <div className={`text-xs mb-1 ${textStyles.lightText}`}>Match score:</div>
                                        <div className="w-full bg-gray-200 rounded-full h-2">
                                            <div
                                                className="bg-blue-600 h-2 rounded-full"
                                                style={{ width: `${Math.max(5, Math.round(card.similarityScore * 100))}%` }}
                                            ></div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                ) : (
                    <div className="text-center p-8 bg-white rounded-lg border">
                        <p className={textStyles.paragraph}>No matching cards found. Try different descriptive words.</p>
                    </div>
                )}
            </div>

            {/* Tech explanation for your coworkers */}
            <div className="mt-12 p-4 border rounded-lg bg-white">
                <h2 className={`text-lg font-semibold mb-2 ${textStyles.subheading}`}>How This Works</h2>
                <p className={`mb-2 ${textStyles.paragraph}`}>This demo simulates a vector search system for aphasia patients:</p>
                <ol className="list-decimal pl-5 space-y-2">
                    <li>When a card is added to the system, an on-device LLM generates a semantic vector embedding capturing its meaning.</li>
                    <li>These embeddings are stored in a vector database (e.g., SQLite with vector extension).</li>
                    <li>When a user types a search query, the LLM generates a vector for that query.</li>
                    <li>The system finds cards with embeddings most similar to the query vector.</li>
                    <li>This semantic matching works even with misspellings or when users can't remember the exact word.</li>
                </ol>
                <p className={`mt-3 text-sm ${textStyles.lightText}`}>Note: This demo uses simulated vectors - a real implementation would generate these using the on-device LLM.</p>
            </div>
        </div>
    );
};

export default AphasiaVectorSearchDemo;