// src/data/embeddingData.js
// Mock embedding vectors (simplistic for demonstration purposes)
// In a real implementation, these would be generated by an on-device LLM
export const mockEmbeddings = {
    "apple": [0.8, 0.1, 0.3, 0.2, 0.1],
    "banana": [0.7, 0.2, 0.5, 0.1, 0.0],
    "water": [0.1, 0.8, 0.2, 0.3, 0.1],
    "coffee": [0.2, 0.7, 0.1, 0.4, 0.3],
    "chair": [0.3, 0.2, 0.8, 0.1, 0.2],
    "table": [0.4, 0.1, 0.7, 0.2, 0.3],
    "dog": [0.5, 0.3, 0.1, 0.8, 0.2],
    "cat": [0.6, 0.2, 0.1, 0.7, 0.3],
    "toothbrush": [0.1, 0.5, 0.3, 0.2, 0.8],
    "comb": [0.2, 0.4, 0.2, 0.3, 0.7]
};

// Mock query embeddings for different search terms
export const mockQueryEmbeddings = {
    // Food-related queries
    "red fruit": [0.8, 0.2, 0.3, 0.1, 0.1],
    "something to eat": [0.7, 0.1, 0.4, 0.1, 0.1],
    "yellow food": [0.7, 0.3, 0.5, 0.0, 0.0],

    // Drink-related queries
    "something to drink": [0.2, 0.8, 0.1, 0.3, 0.2],
    "hot beverage": [0.1, 0.7, 0.2, 0.4, 0.3],

    // Furniture-related queries
    "something to sit on": [0.3, 0.1, 0.8, 0.2, 0.1],
    "furniture": [0.4, 0.2, 0.7, 0.1, 0.2],

    // Animal-related queries
    "pet animal": [0.5, 0.2, 0.1, 0.8, 0.1],
    "animal that barks": [0.5, 0.3, 0.0, 0.8, 0.1],

    // Personal care-related queries
    "bathroom item": [0.2, 0.5, 0.2, 0.3, 0.7],
    "teeth cleaning": [0.1, 0.4, 0.2, 0.2, 0.8]
};

// Mock function to simulate generating query embedding with an LLM
export const generateQueryEmbedding = (query, mockQueryEmbeddings, levenshteinDistance) => {
    // Check if we have a predefined embedding for this query
    const normalizedQuery = query.toLowerCase().trim();

    // Check for exact match
    if (mockQueryEmbeddings[normalizedQuery]) {
        return mockQueryEmbeddings[normalizedQuery];
    }

    // Check for partial matches
    for (const [key, vector] of Object.entries(mockQueryEmbeddings)) {
        if (normalizedQuery.includes(key) || key.includes(normalizedQuery)) {
            return vector;
        }
    }

    // Handle typos
    const words = normalizedQuery.split(/\s+/);
    for (const word of words) {
        for (const [key, vector] of Object.entries(mockQueryEmbeddings)) {
            if (levenshteinDistance(word, key) <= 2 || key.split(/\s+/).some(k => levenshteinDistance(word, k) <= 2)) {
                return vector;
            }
        }
    }

    // Fallback - return a random embedding
    return Object.values(mockQueryEmbeddings)[Math.floor(Math.random() * Object.values(mockQueryEmbeddings).length)];
};